// CPT due: Monday June 18th, 2018
// Sunburned
// image is in this website
// https://well.ca/products/neutrogena-sheer-zinc-suncreen_129165.html?gclid=CjwKCAjwjZjZBRAZEiwAPeLSK7RLa1-zYpyOFi0tKdI6F9J96AEi5iElGzHkwqE9Q3l8raab9SpbwRoCQVwQAvD_BwE

PImage sunscreen;
PVector[] snowflakes;
int xGround, yGround, sec, rightEnemyAmount, leftEnemyAmount, milliseconds, 
    neighbourhoodAlpha, timesClicked;
float jumpSpeed, gravity, xSun, ySun, sunSize, ySunSpeed, ySunDeccel, xButt, 
      yStartButt, buttLength, buttHeight, xCtrlsButt, yCtrlsButt, xStoryButt,   // ...Butt means button btw 
      yStoryButt, xSunSpeed, xSunDeccel, r, g, b, xTrunk, yTrunk, trunkWidth, 
      trunkHeight, xTree, yTree, treeDiameter, xShadow1, yShadow1, xShadow2, 
      yShadow2, xShadow3, yShadow3, q, w, e, test;
String screen;
float xHouse, yHouse, houseWidth, houseHeight, 
      xRoof1, yRoof1, xRoof2, yRoof2, 
      xRoof3, yRoof3, xGarage, yGarage, 
      garageWidth, garageHeight, xGarRoof1, yGarRoof1, 
      xGarRoof2, yGarRoof2, xGarRoof3, yGarRoof3, 
      xGarRoof4, yGarRoof4, ySidewalk, xSnowball, ySnowball, 
      snowflakeSize, xBowtie, yBowtie, bowtieButtLength, bowtieButtHeight,
      xHat, yHat, hatWidth, hatHeight;
float xHead, yHead, headWidth, headHeight, 
      xBody, yBody, bodyWidth, bodyHeight, 
      enemyWidth, enemyHeight, leftJumpSpeed, rightJumpSpeed, enemyGravity, 
      rightTimeInterval, leftTimeInterval, 
      rightEnemyTimer, leftEnemyTimer, sunTimer, xHP, yHP, lengthHP, heightHP, 
      snowballSize, snowballSpeed, slope, slopeWhenClicked, dRight, dLeft, 
      bowtieSmileCorner, bowtieSmileMid, smileCorner, smileMid, xEscButt, yEscButt,
      escButtLength, escButtHeight;
boolean faceRight, takingDmg, isDay, isAlmostDay, inShade, 
        chooseLeft, chooseRight, pickedBowtie, resetSun, snowThrown,
        canClick, faceRightWhenClicked, sunMove;
float[] xRightEnemy, yRightEnemy, xRightEnemySpeed, 
        xLeftEnemy, yLeftEnemy, xLeftEnemySpeed;
boolean[] rightEnemyAlive, leftEnemyAlive;


void setup() {
  size(1100, 650);
  sunscreen = loadImage("sunscreen.jpg");
  timesClicked = -1; // start @ -1 because when you choose character that counts as a click
  
  snowflakeSize = 10;
  snowflakes = new PVector[19];
  for (int i = 0; i < snowflakes.length; i ++) {
    float x = random(width);
    float y = random(-snowflakeSize, height * 0.95);
    snowflakes[i] = new PVector(x, y);
  }

  xGround = 0;
  yGround = 485;

  ySidewalk = yGround - 30;

  houseWidth = width/4;
  houseHeight = height/4;
  xHouse = width/4.5;
  yHouse = ySidewalk - houseHeight;

  xRoof1 = xHouse;
  yRoof1 = yHouse;
  xRoof2 = xHouse + houseWidth/2;
  yRoof2 = yHouse - (houseHeight * 0.5);
  xRoof3 = xHouse + houseWidth;
  yRoof3 = yHouse;

  garageWidth = xHouse * 0.75;
  garageHeight = yHouse * 0.5;
  xGarage = xHouse - garageWidth;
  yGarage = yGround - garageHeight;

  xGarRoof1 = xGarage;
  yGarRoof1 = yGarage;
  xGarRoof2 = xGarage + (garageWidth * 0.2);
  yGarRoof2 = yGarage - (garageHeight * 0.17);
  xGarRoof3 = xGarage + (garageWidth * 0.8);
  yGarRoof3 = yGarRoof2;
  xGarRoof4 = xGarage + garageWidth; 
  yGarRoof4 = yGarage;

  // Player
  bodyWidth = 72;
  bodyHeight = 72;

  xBody = width * 0.4;
  yBody = yGround - bodyHeight/2;
  
  hatWidth = 60; 
  hatHeight = 45;
  
  snowballSize = 25;
  xSnowball = xBody;
  ySnowball = yBody;
  
  isDay = false;
  inShade = false;
  faceRight = true;
  takingDmg = false;
  
  // Right enemies
  rightJumpSpeed = 9;
  enemyGravity = 0.5;
  rightEnemyAmount = 61;
  enemyWidth = 60;
  enemyHeight = 60;
  milliseconds = 1000;
  rightTimeInterval = 2;

  rightEnemyTimer = 9 * milliseconds;                  // 9 secs before enemies start approaching
  xRightEnemy = new float[rightEnemyAmount];
  yRightEnemy = new float[rightEnemyAmount];
  xRightEnemySpeed = new float[rightEnemyAmount];
  rightEnemyAlive = new boolean[rightEnemyAmount];

  for (int i = 0; i < xRightEnemy.length; i ++) {
    xRightEnemy[i] = width + enemyWidth;              // start the enemies coming from the right off-screen beyond canvas width
    yRightEnemy[i] = yGround - enemyHeight;
    xRightEnemySpeed[i] = 0;
    rightEnemyAlive[i] = true;
  }
  
  // Left enemies
  leftTimeInterval = 3;
  leftEnemyTimer = 30 * milliseconds;
  leftEnemyAmount = 44;
  xLeftEnemy = new float[leftEnemyAmount];
  yLeftEnemy = new float[leftEnemyAmount];
  xLeftEnemySpeed = new float[leftEnemyAmount];
  leftEnemyAlive = new boolean[leftEnemyAmount];

  for (int i = 0; i < xLeftEnemy.length; i ++) {
    xLeftEnemy[i] = 0 - enemyWidth * 2;
    yLeftEnemy[i] = yGround - enemyHeight;
    xLeftEnemySpeed[i] = 0;
    leftEnemyAlive[i] = true;
  }

  // HP bar top left corner
  lengthHP = 165;
  heightHP = 25;
  xHP = 20;
  yHP = 25;

  // Buttons
  buttLength = width/2.15;
  buttHeight = 70;
  xButt = width/2 - buttLength/2;
  yStartButt = height*0.45;

  yCtrlsButt = yStartButt + buttHeight + 20;

  yStoryButt = yStartButt + (buttHeight + 20) * 2;
  
  escButtLength = width*0.175;
  escButtHeight = height*0.05;
  xEscButt = width*0.005;
  yEscButt = height*0.01;
  
  xBowtie = width*0.18;
  yBowtie = height *0.23;
  bowtieButtLength = width/4;
  bowtieButtHeight = height/1.5;
  
  // Background Colours
  r = 2;
  g = 1;
  b = 17;

  neighbourhoodAlpha = 125;

  // Tree
  trunkWidth = 65;
  trunkHeight = 175;
  xTrunk = width*0.6;
  yTrunk = yGround - trunkHeight;
  treeDiameter = 155;
  xTree = xTrunk + trunkWidth/2;
  yTree = yTrunk - treeDiameter/4;

  //Shadow
  xShadow1 = xTree;
  yShadow1 = yTree; 
  //xShadow2 = x;
  yShadow2 = yGround; 
  xShadow3 = xTree; 
  yShadow3 = yTrunk + trunkHeight;

  // Sun
  sunSize = 150;
  xSun = width + sunSize/2;
  ySun = height + sunSize;
  ySunSpeed = 2.7;
  ySunDeccel = 0.0055;
  xSunSpeed = 0.9;
  sunTimer = 50 * milliseconds;

  jumpSpeed = 0;
  gravity = 0.5;
  sec = second();
  screen = "menu";                // game starts at menu
}


void menu() {
  background(209, 240, 255);

  noStroke();
  snowfall();

  textSize(120);
  fill(255, 166, 43);
  text("SUNBURNED", (width/2) - width/3, height/3);
  fill(255, 82, 43);
  text("SUNBURNED", (width/2) - width/3.09, height/3);
  textSize(19);
  fill(0);
  text("~ A Game About Skin Protection ~", (width/2) - width/6.3, height*0.39);
  
  textSize(72);
  // Start Button
  noStroke();  
  if (mouseX > xButt && mouseX < xButt + buttLength &&
      mouseY > yStartButt && mouseY < yStartButt + buttHeight) {
    fill(31, 181, 253);
  } else {
    fill(135, 216, 255);
  }
  rect(xButt, yStartButt, buttLength, buttHeight);

  textSize(55);
  fill(23, 54, 125);
  text("START", xButt + buttLength/3.1, yStartButt + 55);

  // Controls Button
  if (mouseX > xButt && mouseX < xButt + buttLength &&
      mouseY > yCtrlsButt && mouseY < yCtrlsButt + buttHeight) {
    fill(249, 155, 211);
  } else {
    fill(255, 195, 232);
  }
  rect(xButt, yCtrlsButt, buttLength, buttHeight);

  textSize(55);
  fill(201, 36, 135);
  text("CONTROLS", xButt + buttLength/5.6, yCtrlsButt + 55);

  // Story Button
  if (mouseX > xButt && mouseX < xButt + buttLength &&
      mouseY > yStoryButt && mouseY < yStoryButt + buttHeight) {
    fill(105, 141, 224);
  } else {
    fill(161, 189, 255);
  }
  rect(xButt, yStoryButt, buttLength, buttHeight);

  textSize(55);
  fill(76, 7, 168);
  text("STORY", xButt + buttLength/3.1, yStoryButt + 55);
}

void controls() {
  background(200, 246, 130);
  
  // Backspace button / esc
  noStroke();
  if (mouseX > xEscButt && mouseX < xEscButt + escButtLength &&
      mouseY > yEscButt && mouseY < yEscButt + escButtHeight) {
    fill(53, 102, 1);
  } else {
    fill(89, 173, 0);
  }
  rect(xEscButt, yEscButt, escButtLength, escButtHeight);
  textSize(19);
  fill(255);
  text("[Backspace] to esc", width*0.0135, height*0.044);
  
  textSize(25);
  fill(0);
  text("to jump", 330, 83);
  textSize(40);
  text("     [w]", 98.5, 120);
  text("[a]  [s]  [d]      [space]", 95, 180);
  
  textSize(25);
  text("move left              move right", 26, 230);
  text("fall down quickly", 99, 280);
  
  stroke(0);
  strokeWeight(3);
  // "jump" lines 
  line(340, 96, 245, 100);         // [w]
  line(340, 96, 405, 140);        // [space]
  // "move left" line
  line(62, 200, 88, 175);         // [a]
  // "move right" line
  line(325, 200, 300, 175);       // [d]
  // "move down quickly" line
  line(193.5, 204, 193.5, 250);   // [s]
  
  text("You'll have an HP gauge in the top", width*0.54, 70);
  text("left corner of your screen.", width*0.54, 105);
  text("Avoid being touched by the kids or", width*0.54, 140);
  text("you'll lose HP!", width*0.54, 175);
  text("Click on the screen to throw your snowball!", width*0.46, 240);
  text("Remember! You can only throw ahead of you,", width*0.46, 275);
  text("so make sure you're facing the direction", width*0.46, 310); 
  text("you want to throw in before you click.", width*0.46, 345);
  
  text("You can only throw one snowball at a time, so make your shots count :)", 40, 410);
  text("(You basically gotta wait till your snowball is", 40, 445);
  text(" off-screen before you can shoot again b/c you", 40, 480);
  text("have no hands and making snowballs are hard)", 40, 515);
  
  text("Hide behind the tree and its shadows to avoid sunburning!", 40, 590);
  text("(don't worry if you're not EXACTLY within the shadow--you'll still be shielded.", 40, 625);
  
  // draw cursor
  fill(255);
  beginShape(); // this is so cool
  vertex(960, 450);
  vertex(960, 516);
  vertex(977, 500);
  vertex(989, 529);
  vertex(1011, 519);
  vertex(992, 492);
  vertex(1008, 487);
  vertex(959, 450);
  endShape();
  // WHOOSH lines
  line(832, 458, 740, 485);
  line(823, 485, 727, 515);
  line(845, 496, 746, 532);
  line(852, 518, 782, 557);
  line(867, 532, 805, 569);
  // Snowball
  noStroke();
  ellipse(840, 500, 90, 90);
  // some sick sound FXXXXX
  textSize(19);
  fill(0);
  text("*click*", 959, 440);
  text("*WHOOSH*", 869, 567);
}

void story() {
  background(22, 146, 170);
  
  // Backspace button / esc
  noStroke();
  if (mouseX > xEscButt && mouseX < xEscButt + escButtLength &&
      mouseY > yEscButt && mouseY < yEscButt + escButtHeight) {
    fill(0, 70, 81);
  } else {
    fill(0, 101, 117);
  }
  rect(xEscButt, yEscButt, escButtLength, escButtHeight);
  textSize(19);
  fill(209, 244, 255);
  text("[Backspace] to esc", width*0.0135, height*0.044);
  
  textSize(25);
  fill(255);
  text("Welcome to this world, Snowman.", width*0.02, height*0.12);
  text("You were created by the", width*0.02, height*0.17);
  text("neighbourhood children, just like Frosty.", width*0.02, height*0.22);
  text("But unlike Frosty, you don't have a top hat to shield you from the sun. Oh no! UV rays!", width*0.02, height*0.4);
  text("You look for your hat but run into the neighbourhood kids instead.", width*0.02, height*0.5);
  text("All kids adore snowmen--a little too much for your taste, however.", width*0.02, height*0.6);
  text("You fight off the kids but the Sun is your enemy too!", width*0.02, height*0.7);
  text("Luckily, the sun is only out for a short amount of time mainly due to technical", width*0.02, height*0.75);
  text("difficulties and incompetent programmers.", width*0.02, height*0.8);
  text("Survive the onslaught of children by using your one singular snowball and", width*0.02, height*0.85);
  text("hide in the shade during the day! You're not about skin cancer.", width*0.02, height*0.9);
  text("Maybe one day you'll find your hat?", width*0.02, height*0.95);
  
  // Top hat
  fill(0);
  rect(600, 30, 100, 75);
  rect(575, 105, 150, 25);
  fill(160, 0, 0);
  rect(600, 85, 100, 20);
  textSize(45);
  text("?", 720, 55);
}

void chooseCharacter() {
  background(209, 240, 255);
  snowfall();
  
  // Backspace button / esc
  noStroke();
  if (mouseX > xEscButt && mouseX < xEscButt + escButtLength &&
      mouseY > yEscButt && mouseY < yEscButt + escButtHeight) {
    fill(105, 198, 224);
  } else {
    fill(165, 229, 247);
  }
  rect(xEscButt, yEscButt, escButtLength, escButtHeight);
  fill(0);
  textSize(19);
  text("[Backspace] to esc", width*0.0135, height*0.044);
  
  fill(0);
  textSize(71);
  text("CHOOSE YOUR CHARACTER", width*0.07, height*0.18);
  textSize(30);
  text("Bowtie", xBowtie + bowtieButtLength/3.1, yBowtie + bowtieButtHeight*1.09);
  text("No-tie", xBowtie + bowtieButtLength*1.86, yBowtie + bowtieButtHeight*1.09);

  if (mouseX > xBowtie && mouseX < xBowtie + bowtieButtLength &&                                      // if mouse is hovering on the left button...
      mouseY > yBowtie && mouseY < yBowtie + bowtieButtHeight) {
    chooseLeft = true;
    chooseRight = false;
    
  } else if (mouseX > xBowtie + bowtieButtLength*1.5 && mouseX < xBowtie + bowtieButtLength*2.5 &&    // if mouse is hovering on the right button...
             mouseY > yBowtie && mouseY < yBowtie + bowtieButtHeight) {
    chooseRight = true;
    chooseLeft = false;
  } else {
    chooseRight = false;
    chooseLeft = false;
  }
  
  if (chooseLeft) {
    fill(72, 22, 189);                                                                                // left button gets darker when mouse hovers over it
  } else {
    fill(124, 148, 255);                                                                              // left button's normal light purple colour
  }
  rect(xBowtie, yBowtie, bowtieButtLength, bowtieButtHeight);                                         // draw left button
  
  if (chooseRight) {
    fill(72, 22, 189);                                                                                // right button gets darker when mouse hovers over it
  } else {
    fill(124, 148, 255);                                                                              // right button's normal light purple colour
  }
  rect(xBowtie + bowtieButtLength*1.5, yBowtie, bowtieButtLength, bowtieButtHeight);                  // draw right button
 
  // Bowtie snowman
  // bowtie                                                                                           
  fill(255, 155, 220);
  stroke(255, 71, 190);
  strokeWeight(3);
  ellipse(xBowtie + bowtieButtLength/2 + 4, yBowtie + bowtieButtHeight/1.95 - 36, 18, 25);
  ellipse(xBowtie + bowtieButtLength/2 - 9, yBowtie + bowtieButtHeight/1.95 - 36, 15, 15);
  ellipse(xBowtie + bowtieButtLength/2 - 23, yBowtie + bowtieButtHeight/1.95 - 34, 19, 25);
  noStroke();
  // body
  fill(250, 250, 250);
  ellipse(xBowtie + bowtieButtLength/2, yBowtie + bowtieButtHeight/1.5, 102, 102);
  // head
  fill(254, 254, 254);
  ellipse(xBowtie + bowtieButtLength/2, yBowtie + bowtieButtHeight/1.95, 68, 68);
  // its right eye
  fill(0);
  ellipse(xBowtie + bowtieButtLength/2, yBowtie + bowtieButtHeight/1.95 - 6.8, 6.8, 6.8);
  // its left eye
  ellipse(xBowtie + bowtieButtLength/2 + 22.6, yBowtie + bowtieButtHeight/1.95 - 6.8, 6.8, 6.8);
  if (chooseLeft) {                                                                                   // Bowtie snowman will frown when chosen :( no one likes being chosen to get beat up by enemies
    bowtieSmileCorner = 20; 
    bowtieSmileMid = 17;
    smileCorner = 17;
    smileMid = 20;
  } else if (chooseRight) {                                                                           // No-tie snowman will frown when chosen :( 
    bowtieSmileCorner = 17; 
    bowtieSmileMid = 20;
    smileCorner = 20;
    smileMid = 17;
  } else {                                                                                            // Bowtie and No-tie snowman will both smile when mouse is not hovering over either of them :)
    bowtieSmileCorner = 17; 
    bowtieSmileMid = 20;
    smileCorner = 17;
    smileMid = 20;
  }
  // smile
  ellipse(xBowtie + bowtieButtLength/2, yBowtie + bowtieButtHeight/1.95 + bowtieSmileCorner, 3.4, 3.4);
  ellipse(xBowtie + bowtieButtLength/2 + 6.8, yBowtie + bowtieButtHeight/1.95 + bowtieSmileMid, 3.4, 3.4);
  ellipse(xBowtie + bowtieButtLength/2 + 13.6, yBowtie + bowtieButtHeight/1.95 + bowtieSmileMid, 3.4, 3.4);
  ellipse(xBowtie + bowtieButtLength/2 + 20.4, yBowtie + bowtieButtHeight/1.95 + bowtieSmileCorner, 3.4, 3.4);
  // carrot nose
  fill(252, 212, 11);
  triangle(xBowtie + bowtieButtLength/2 + 11.3, yBowtie + bowtieButtHeight/1.95 + 2.72,
           xBowtie + bowtieButtLength/2 + 30.9, yBowtie + bowtieButtHeight/1.95 + 4.25,
           xBowtie + bowtieButtLength/2 + 11.3, yBowtie + bowtieButtHeight/1.95 + 11.3);
   
  // No-tie snowman         
  // body                                                                                              
  fill(250, 250, 250);
  ellipse(xBowtie + bowtieButtLength*1.5 + bowtieButtLength/2, yBowtie + bowtieButtHeight/1.5, 102, 102);
  // head
  fill(254, 254, 254);
  ellipse(xBowtie + bowtieButtLength*1.5 + bowtieButtLength/2, yBowtie + bowtieButtHeight/1.95, 68, 68);
  // its left eye
  fill(0);
  ellipse(xBowtie + bowtieButtLength*1.5 + bowtieButtLength/2, yBowtie + bowtieButtHeight/1.95 - 6.8, 6.8, 6.8);
  // its right eye
  ellipse(xBowtie + bowtieButtLength*1.5 + bowtieButtLength/2 - 22.6, yBowtie + bowtieButtHeight/1.95 - 6.8, 6.8, 6.8);
  // smile
  ellipse(xBowtie + bowtieButtLength*1.5 + bowtieButtLength/2, yBowtie + bowtieButtHeight/1.95 + smileCorner, 3.4, 3.4);
  ellipse(xBowtie + bowtieButtLength*1.5 + bowtieButtLength/2 - 6.8, yBowtie + bowtieButtHeight/1.95 + smileMid, 3.4, 3.4);
  ellipse(xBowtie + bowtieButtLength*1.5 + bowtieButtLength/2 - 13.6, yBowtie + bowtieButtHeight/1.95 + smileMid, 3.4, 3.4);
  ellipse(xBowtie + bowtieButtLength*1.5 + bowtieButtLength/2 - 20.4, yBowtie + bowtieButtHeight/1.95 + smileCorner, 3.4, 3.4);
  // carrot nose
  fill(252, 212, 11);
  triangle(xBowtie + bowtieButtLength*1.5 + bowtieButtLength/2 - 11.3, yBowtie + bowtieButtHeight/1.95 + 2.72,
           xBowtie + bowtieButtLength*1.5 + bowtieButtLength/2 - 30.9, yBowtie + bowtieButtHeight/1.95 + 4.25,
           xBowtie + bowtieButtLength*1.5 + bowtieButtLength/2 - 11.3, yBowtie + bowtieButtHeight/1.95 + 11.3);
  
}

void mouseReleased() {
  if (screen.equals("menu")) {
    if (mouseX > xButt && mouseX < xButt + buttLength &&
        mouseY > yStartButt && mouseY < yStartButt + buttHeight) {
      screen = "chooseCharacter";
    } else if (mouseX > xButt && mouseX < xButt + buttLength &&
               mouseY > yCtrlsButt && mouseY < yCtrlsButt + buttHeight) { 
      screen = "controls";
    } else if (mouseX > xButt && mouseX < xButt + buttLength &&
               mouseY > yStoryButt && mouseY < yStoryButt + buttHeight) {
      screen = "story";
    }
  } else if (screen.equals("chooseCharacter")) {
    if (mouseX > xBowtie && mouseX < xBowtie + bowtieButtLength &&
        mouseY > yBowtie && mouseY < yBowtie + bowtieButtHeight) {
      pickedBowtie = true; 
      screen = "gameScreen";
    } else if (mouseX > xBowtie + bowtieButtLength*1.5 && mouseX < xBowtie + bowtieButtLength*2.5 &&
               mouseY > yBowtie && mouseY < yBowtie + bowtieButtHeight) {
      pickedBowtie = false;
      screen = "gameScreen";
    } else if (mouseX > xEscButt && mouseX < xEscButt + escButtLength &&
               mouseY > yEscButt && mouseY < yEscButt + escButtHeight) {
      screen = "menu";
    }
  } else if (screen.equals("controls") || screen.equals("story")) {
    if (mouseX > xEscButt && mouseX < xEscButt + escButtLength &&
        mouseY > yEscButt && mouseY < yEscButt + escButtHeight) {
      screen = "menu";
    }
  } 
}

void sky() {
  // changing sky colour
  if (isAlmostDay) {                                             
    r += 0.3;
    g += 0.4;
    b += 1.1;
    neighbourhoodAlpha -= 0.1;
  } else {
    r -= 0.3;
    g -= 0.4; 
    b -= 1.1;
    neighbourhoodAlpha += 0.1;
  }

  if (r < 2 || g < 1 || b < 17) {                                // boundary so sky doesn't keep subtracting til 0 and go black
    r = 2;
    g = 1;
    b = 17;
  } else if (r > 169.10095 || g > 223.79887 || b > 629.6994) {   // boundary so sky doesn't keep adding til 255 and go white
    r = 169.10095;
    g = 223.79887;
    b = 629.6994;
  }
  
  if (neighbourhoodAlpha < 2) {
    neighbourhoodAlpha = 2;
  } else if (neighbourhoodAlpha > 125) {
    neighbourhoodAlpha = 125;
  }
  background(r, g, b);

  // too many loops? lags game a lot
  // layered sky look
  for (int i = 0; i < 9; i ++) {
    fill(r + (i * 1.5), g + (i), b + (i * 5));
    ellipse(width/2, height/1.25, width*1.75 - (i * 65), (height * 1.75) - (i * 65));
  }
}

void snowfall() {                           
  for (int i = 0; i < snowflakes.length; i ++) {
    // Snowflake movement
    snowflakes[i].add(random(-0.7, 0.7), 1);                    // Trying to make the snowflakes go back and forth a bit to make it seem kind of like wind

    // Boundary check
    if (isAlmostDay == false) {                                 // Only resets snowflake position at the top of screen when it's night (only snows at night and in title/menu and character selection screens)
      if (snowflakes[i].y > ySidewalk + snowflakeSize) {        // if snowflake passes the ground (out of view) ...
        snowflakes[i].x = random(width);                        // randomly resets snowflake's xPosition within the specified domain
        snowflakes[i].y = random(-350, -snowflakeSize);         // randomly resets the snowflake's yPosition within the specified range
      }
    }
    // Draw snowflake
    fill(255, 255, 255, 175);                                   // not fully white b/c snowflakes are in background
    ellipse(snowflakes[i].x, snowflakes[i].y, snowflakeSize, snowflakeSize);
  }
  
}

void sun() {
  // Sun
  fill(255, 255, 102);
  ellipse(xSun, ySun, sunSize, sunSize);
 
  // Sun movement 
  // due to lots difficulties, the sun is only able to come up once throughout the whole game :)))))) great
  
  if (millis() > sunTimer) {                                                    // sun will move after specified amount of time passes
    sunMove = true;
  } else {
    
  }
  //if (millis() > sunTimer) {
  //  if (ySun > height + sunSize) {
  //    ySunSpeed = 10;
  //  } else if (ySun <= height + sunSize) {
  //    ySunSpeed = 0;
  //    sunMove = true;
  //  }
  //   //xSun = width + sunSize/2;
  //   //ySun = height + sunSize;
    
  //}

  if (sunMove) {                                                
    xSun -= xSunSpeed;                                                            // essentially, sun is taking one big slow-ish jump when moving into sky (to travel in an arch)
    ySun -= ySunSpeed;
    ySunSpeed -= ySunDeccel;
  }
    
  if (xSun <= width && xSun >= 0 && ySun < ySidewalk + sunSize/3) {              // Becomes day basically when sun is visible
    isDay = true;
  } else {
    isDay = false;
  }
  
  if (xSun <= width && xSun >= width*0.28 && ySun < height + sunSize) {          // "Almost day" is to check when the sun is about to rise so the snow can stop falling sooner and so the sky can start changing colour sooner than when it's already day
    isAlmostDay = true;
  } else {
    isAlmostDay = false;
  }
}

void shadow() {
  // Pythagorean theorem? to make shadows relative to the sun's position in the sky
  q = yGround - ySun;        // a (vertical part of triangle)
  e = 345;                   // c (hypotenuse)
  w = sqrt((e*e) - (q*q));   // b (horizontal part of triangle)
  
  // Shadow is just black with lowered opacity
  fill(0, 0, 0, 190);     
  if (isAlmostDay) {
    if (xSun > xTrunk + trunkWidth/2) {                                             // if sun is right of tree, shadow points towards left
      triangle(xShadow1, yShadow1, ((xTrunk + trunkWidth / 2) - w), 
               yShadow2, xShadow3, yShadow3);
      if (xBody > (xTrunk + trunkWidth / 2) - w && xBody < xTrunk + trunkWidth) {   // in triangle shadow or behind tree trunk
        inShade = true;
      } else if (xBody > xTrunk && xBody < xTrunk + trunkWidth) {                   // just behind tree trunk (when triangle shadow is gone)
        inShade = true;
      } else {
        inShade = false;
      }
    } else {                                                                        // if sun is left of tree, shadow points towards right
      triangle(xShadow1, yShadow1, (xTrunk + trunkWidth/2 + w),  
               yShadow2, xShadow3, yShadow3);
      if (xBody < (xTrunk + xTrunk / 2) + w && xBody > xTrunk) {                    // in triangle shadow or behind tree trunk
        inShade = true;
      } else if (xBody > xTrunk && xBody < xTrunk + trunkWidth) {                   // just behind tree trunk (when triangle shadow is gone)
        inShade = true;
      } else {
        inShade = false;
      }
    }   
  }
}

void neighbourhood() {
  // should probably choose different colours
  // House
  fill(215, 192, 173);
  rect(xHouse, yHouse, houseWidth, houseHeight);
  // House door
  fill(252, 238, 168);
  rect(xHouse + houseWidth/2 - 35, yHouse + houseHeight/2, 70, houseHeight/2);
  // House roof
  fill(132, 121, 110);
  triangle(xRoof1, yRoof1, xRoof2, 
           yRoof2, xRoof3, yRoof3);

  // Garage
  fill(218, 170, 128);
  rect(xGarage, yGarage, garageWidth, garageHeight);
  // Garage door
  fill(175, 121, 94);
  rect(xGarage + garageWidth/2 - 73, yGarage + 35, garageWidth * 0.8, 100);
  // Garage roof
  fill(95, 41, 31);
  quad(xGarRoof1, yGarRoof1, xGarRoof2, yGarRoof2, 
       xGarRoof3, yGarRoof3, xGarRoof4, yGarRoof4);


  // SHADOW (alpha)                                  // redrawing all the neighbourhood but now putting a shaded version on top for that nighttime effect?
  // House
  fill(0, 0, 0, neighbourhoodAlpha);
  rect(xHouse, yHouse, houseWidth, houseHeight);
  // House door
  rect(xHouse + houseWidth/2 - 35, yHouse + houseHeight/2, 70, houseHeight/2);
  // House roof
  triangle(xRoof1, yRoof1, xRoof2, 
           yRoof2, xRoof3, yRoof3);

  // Garage
  rect(xGarage, yGarage, garageWidth, garageHeight);
  // Garage door
  rect(xGarage + garageWidth/2 - 73, yGarage + 35, garageWidth * 0.8, 100);
  // Garage roof
  quad(xGarRoof1, yGarRoof1, xGarRoof2, yGarRoof2, 
       xGarRoof3, yGarRoof3, xGarRoof4, yGarRoof4);
}

void tree() {
  // Tree Trunk
  fill(65, 36, 9);
  rect(xTrunk, yTrunk, trunkWidth, trunkHeight);
  fill(67, 39, 12);
  rect(xTrunk + trunkWidth/6, yTrunk, trunkWidth*0.65, trunkHeight);

  // Tree leaves
  for (int i = 0; i < 6; i++) {                    
    fill(79 + i*4, 168 + i*7, 10 + i*11);                  // to make the tree look kind of more cool with more shades
    ellipse(xTree + i*5, yTree - i*7.5, treeDiameter - (i*19), treeDiameter - (i*19));
  }
}

void player() {
  // drawing snowman
  if (pickedBowtie) {                   // if player chose the bowtie snowman
    // Bowtie
    strokeWeight(2);
    if (inShade) {
      fill(179, 127, 160);             // bowtie turns darker in b/c in shadow
      stroke(156, 8, 102);
    } else {
      fill(255, 155, 220);             // regular bowtie colour
      stroke(255, 71, 190);
    }
    if (faceRight) {                   // bowtie is facing certain way depending which way the snowman is facing
      ellipse(xHead + headWidth*0.05, yHead - headHeight*0.529, headWidth*0.26, headHeight*0.367);
      ellipse(xHead - headWidth*0.13, yHead - headHeight*0.529, headWidth*0.22, headHeight*0.22);
      ellipse(xHead - headWidth*0.338, yHead - headHeight/2, headWidth*0.279, headHeight*0.367);
      noStroke();
    } else {
      ellipse(xHead - headWidth*0.05, yHead - headHeight*0.529, headWidth*0.26, headHeight*0.367);
      ellipse(xHead + headWidth*0.13, yHead - headHeight*0.529, headWidth*0.22, headHeight*0.22);
      ellipse(xHead + headWidth*0.338, yHead - headHeight/2, headWidth*0.279, headHeight*0.367);
      noStroke();
    }
  }
  if (inShade) {
    fill(190, 190, 190);              // snowman's body turns darker b/c in shadow 
  } else {
    fill(250, 250, 250);              // normal colour of snowman's body
  }
  ellipse(xBody, yBody, bodyWidth, bodyHeight);
  if (inShade) {
    fill(194, 194, 194);              // snowman's head turns darker b/c in shadow
  } else {
    fill(254, 254, 254);              // normal colour of snowman's head
  }
  ellipse(xHead, yHead, headWidth, headHeight);
  
  // snowman's face
  if (faceRight) {                                      // player facing right
    // its right eye
    fill(0);
    ellipse(xHead, yHead - headHeight/10, 
            headWidth/10, headHeight/10);
    // its left eye
    ellipse(xHead + headWidth/3, yHead - headHeight/10, 
            headWidth/10, headHeight/10);      

    if (isDay) {                        // Snowman becomes upset if the sun is out :( poor guy
      // frown
      ellipse(xHead, yHead + headHeight/3.5, 
              headWidth/20, headHeight/20);
      ellipse(xHead + headWidth/10, yHead + headHeight/4, 
              headWidth/20, headHeight/20);
      ellipse(xHead + headWidth/5, yHead + headHeight/4, 
              headWidth/20, headHeight/20);
      ellipse(xHead + headWidth/10 * 3, yHead + headHeight/3.5, 
              headWidth/20, headHeight/20);
    } else {
      // smile
      ellipse(xHead, yHead + headHeight/4, 
              headWidth/20, headHeight/20);
      ellipse(xHead + headWidth/10, yHead + headHeight/3.5, 
              headWidth/20, headHeight/20);
      ellipse(xHead + headWidth/5, yHead + headHeight/3.5, 
              headWidth/20, headHeight/20);
      ellipse(xHead + headWidth/10 * 3, yHead + headHeight/4, 
              headWidth/20, headHeight/20);
    }
    // carrot nose
    fill(252, 212, 11);
    triangle(xHead + headWidth/6, yHead + headHeight/25, 
             xHead + headWidth/2.2, yHead + headHeight/16, 
             xHead + headWidth/6, yHead + headHeight/6);
  } else {                                // player facing left
    // its left eye
    fill(0);
    ellipse(xHead, yHead - headHeight/10, 
            headWidth/10, headHeight/10);
    // its left eye
    ellipse(xHead - headWidth/3, yHead - headHeight/10, 
            headWidth/10, headHeight/10);
    if (isDay) {
      // frown                                          // Snowman ain't a fan of the sun :(
      ellipse(xHead, yHead + headHeight/3.5, 
              headWidth/20, headHeight/20);
      ellipse(xHead - headWidth/10, yHead + headHeight/4, 
              headWidth/20, headHeight/20);
      ellipse(xHead - headWidth/5, yHead + headHeight/4, 
              headWidth/20, headHeight/20);
      ellipse(xHead - headWidth/10 * 3, yHead + headHeight/3.5, 
              headWidth/20, headHeight/20);
    } else {
      // smile
      ellipse(xHead, yHead + headHeight/4, 
              headWidth/20, headHeight/20);
      ellipse(xHead - headWidth/10, yHead + headHeight/3.5, 
              headWidth/20, headHeight/20);
      ellipse(xHead - headWidth/5, yHead + headHeight/3.5, 
              headWidth/20, headHeight/20);
      ellipse(xHead - headWidth/10 * 3, yHead + headHeight/4, 
              headWidth/20, headHeight/20);
    }
    // carrot nose
    fill(252, 212, 11);
    triangle(xHead - headWidth/6, yHead + headHeight/25, 
             xHead - headWidth/2.2, yHead + headHeight/16, 
             xHead - headWidth/6, yHead + headHeight/6);
  }
}

void snowball() {
  // Your singular snowball
  fill(255);
  ellipse(xSnowball, ySnowball, snowballSize, snowballSize);
  
  if (snowThrown) {                                                        // snowball won't hurt enemies unless thrown/shot first
    for (int i = 0; i < xRightEnemy.length; i ++) {                        // if snowball touches enemies coming from the right...
      if (i != 60) {                                                       // Right enemy #60 is the last right enemy and holds your TOP HAT which lets you win the game. So don't kill it pls
        if (xSnowball + snowballSize/2 > xRightEnemy[i] && 
          xSnowball - snowballSize/2 < xRightEnemy[i] + enemyWidth &&
          ySnowball + snowballSize/2 > yRightEnemy[i] && 
          ySnowball + snowballSize/2 < yRightEnemy[i] + enemyHeight) {
    
          //textSize(30);
          //fill(255);
          //text("OuCH", width/2, 100);
          rightEnemyAlive[i] = false;                                        // kids will die
        }
      }
    }
  
    for (int i = 0; i < xLeftEnemy.length; i++) {                          // if snowball touches enemies coming from the left...
      if (xSnowball + snowballSize/2 > xLeftEnemy[i] && 
        xSnowball - snowballSize/2 < xLeftEnemy[i] + enemyWidth &&
        ySnowball + snowballSize/2 > yLeftEnemy[i] && 
        ySnowball + snowballSize/2 < yLeftEnemy[i] + enemyHeight) {
  
        //textSize(30);
        //fill(255, 50, 255);
        //text("OuCH", width/2 + 50, 100);
        leftEnemyAlive[i] = false;                                         // enemy will die
      }
    }
  }
  
  // Snowball Movement 
  // Can only shoot snowball in the direction the snowman is facing
  if (faceRightWhenClicked) {                                                                // if the snowman was facing right when the shot was fired ...
    xSnowball += snowballSpeed;
    ySnowball += slope * snowballSpeed;                                                      // angle the snowball shoots in is dependent on where the player clicks on the screen
  } else {                                                                                   // if the snowman was facing left when the shot was fired...
    xSnowball -= snowballSpeed;
    ySnowball -= slope *snowballSpeed;
  }
  
  if (snowThrown) {
    snowballSpeed = 9;
  } else {                                                                                   // resets snowball at snowman's body
    //snowballSpeed = 0;                                                                       
    //slope = 0;
    xSnowball = xBody;
    ySnowball = yBody;
  }
  
  if (xSnowball == xBody && ySnowball == yBody) {                                            // can shoot snowball only if it's at the snowman's body first
    canClick = true;
  } else {
    canClick = false;
  }
  
  if (xSnowball - snowballSize/2 > width || xSnowball + snowballSize/2 < 0 ||
      ySnowball - snowballSize/2 > yGround || ySnowball + snowballSize/2 < 0) {        // if the snowball flies out of view, it resets at the snowman's body
    snowThrown = false;
  }
  
}

void enemies() {                                                                        // neighbourhood children are your enemies
  // what do the enemies have in common?
  for (int i = 0; i < xRightEnemy.length; i ++) {                                       // RIGHT ENEMIES
    if (rightEnemyAlive[i]) {
      if (millis() > rightEnemyTimer + (i * rightTimeInterval * milliseconds)) {        // Assigns a speed to right enemies after certain amount of time
        
        if (i <= 25) {           // first 25 enemies are slower or easier
          if (i % 5 == 0) {      // every 5 enemies (and 0) --> move slower
            xRightEnemySpeed[i] = 3; 
          } else {
            xRightEnemySpeed[i] = 4;
          }
          //// Right enemy speech. Layers too much
          //textSize(19);
          //fill(0);
          //text("Oh, look!", xRightEnemy[0] - enemyWidth/2, yRightEnemy[0] + enemyHeight*1.4);
          //text("A snowman!", xRightEnemy[0] - enemyWidth/2, yRightEnemy[0] + enemyHeight*1.8);
          //text("Wow, gnarly", xRightEnemy[2] - enemyWidth/2, yRightEnemy[2] + enemyHeight*1.4);
          //text("2 fast 2 be last", xRightEnemy[15] - enemyWidth/2, yRightEnemy[15] + enemyHeight*1.4);
        } else if (i > 25 && i <= 59) {
          if (i % 4 == 0) {      // every 4 will JUMP
            xRightEnemySpeed[i] = 3;
            yRightEnemy[i] -= rightJumpSpeed;
            rightJumpSpeed -= enemyGravity;
            if (yRightEnemy[i] + enemyHeight > yGround) {
              rightJumpSpeed = 9;
            }
            textSize(19);
            fill(0);
            text("ate too much sugar", xRightEnemy[i] - enemyWidth/2, yRightEnemy[i] + enemyHeight*1.4);
            
          } else {
            xRightEnemySpeed[i] = 7;
          }
        } else {
          xRightEnemySpeed[60] = 1;                                               
          if (xRightEnemy[60] < width/2) {                                        // stop in middle of screen
            xRightEnemy[60] = width/2;
          }
          
          // Draw TOP HAT!
          xHat = xRightEnemy[60];
          yHat = yRightEnemy[60] - enemyHeight;
          fill(0);
          rect(xHat, yHat, hatWidth, hatHeight);
          rect(xHat - hatWidth/4, yHat + hatHeight, hatWidth*1.5, hatHeight/3);
          fill(160, 0, 0);
          rect(xHat, yHat + hatHeight - hatHeight*0.26, hatWidth,  hatHeight*0.26);
          if (xBody > xHat && xBody < xHat + hatWidth && yBody > yHat) {         // if touch TOP HAT --> WIN!
            screen = "win";
          }
        }
      }      
      
      xRightEnemy[i] -= xRightEnemySpeed[i];

      // DAMAGE FROM THE RIGHT
      dRight = dist(xRightEnemy[i], yRightEnemy[i], xBody, yBody);
      if (dRight < bodyWidth) {
        takingDmg = true;
        if (lengthHP >= 0) {
          lengthHP -= 0.33;
        }
      } 

      // Top POM POM                                                                    // Children in their blue winter gear
      fill(218, 255, 239);
      ellipse(xRightEnemy[i] + enemyWidth/1.39, yRightEnemy[i] - enemyWidth/2.2, 
              enemyWidth*0.45, enemyWidth*0.4);
      // left POM POM
      ellipse(xRightEnemy[i], yRightEnemy[i] + enemyHeight*0.75, 
              enemyWidth*0.3, enemyWidth*0.3);
      // Head
      fill(167, 206, 203);
      rect(xRightEnemy[i], yRightEnemy[i], enemyWidth, enemyHeight);
      // Hat
      fill(100, 182, 172);
      ellipse(xRightEnemy[i] + enemyWidth/1.87, yRightEnemy[i] + enemyHeight*0.25, 
              enemyWidth * 1.2, enemyHeight * 1.25);      
      // Stripe on hat
      fill(223, 255, 242);
      ellipse(xRightEnemy[i] + enemyWidth/2, yRightEnemy[i] + enemyHeight/2.5, 
              enemyWidth*1.1, enemyHeight*1.15);
      fill(100, 182, 172);
      ellipse(xRightEnemy[i] + enemyWidth/2, yRightEnemy[i] + enemyHeight/2.3, 
              enemyWidth*1.05, enemyHeight*1.1);
      // Face colour
      fill(167, 206, 203);
      ellipse(xRightEnemy[i] + enemyWidth/2, yRightEnemy[i] + enemyHeight/2, 
              enemyWidth, enemyHeight);
      // Their left eye (our right)
      fill(0);
      ellipse(xRightEnemy[i] + enemyWidth/1.7, yRightEnemy[i] + enemyHeight*0.4, 
              enemyWidth * 0.1, enemyHeight * 0.2);
      // Their right eye (our left)
      ellipse(xRightEnemy[i] + enemyWidth * 0.25, yRightEnemy[i] + enemyHeight * 0.4, 
              enemyWidth * 0.1, enemyHeight * 0.2);
      // mouth
      strokeWeight(2.5);
      stroke(0);
      line(xRightEnemy[i] + enemyWidth * 0.3, yRightEnemy[i] + enemyHeight * 0.64, 
           xRightEnemy[i] + enemyWidth * 0.4, yRightEnemy[i] + enemyHeight * 0.74);
      line(xRightEnemy[i] + enemyWidth * 0.4, yRightEnemy[i] + enemyHeight * 0.74, 
           xRightEnemy[i] + enemyWidth * 0.52, yRightEnemy[i] + enemyHeight * 0.64);
      noStroke();      
      // Scarf
      fill(93, 115, 126);
      rect(xRightEnemy[i], yRightEnemy[i] + enemyHeight*0.75, 
           enemyWidth, enemyHeight*0.25);
      fill(252, 255, 253);
      rect(xRightEnemy[i] + enemyWidth*0.2, yRightEnemy[i] + enemyHeight*0.75, 
           enemyWidth * 0.8, enemyHeight*0.25);
      fill(93, 115, 126);
      rect(xRightEnemy[i] + enemyWidth*0.4, yRightEnemy[i] + enemyHeight*0.75, 
           enemyWidth * 0.6, enemyHeight*0.25);
      fill(252, 255, 253);
      rect(xRightEnemy[i] + enemyWidth*0.6, yRightEnemy[i] + enemyHeight*0.75, 
           enemyWidth * 0.4, enemyHeight*0.25);
      fill(93, 115, 126);
      rect(xRightEnemy[i] + enemyWidth*0.8, yRightEnemy[i] + enemyHeight*0.75, 
           enemyWidth * 0.2, enemyHeight*0.25);
      // Right POM POM
      fill(218, 255, 239);
      ellipse(xRightEnemy[i] + enemyWidth, yRightEnemy[i] + enemyHeight*0.75, 
              enemyWidth*0.3, enemyWidth*0.3);
    }
  }
  for (int i = 0; i < xLeftEnemy.length; i ++) {                                       // LEFT ENEMIES
    if (leftEnemyAlive[i]) {
      if (millis() > leftEnemyTimer + (i * leftTimeInterval * milliseconds)) {         // Assigns a speed to left enemies after certain amount of time

        if (i <= 15) {                                                                 // the first 15 enemies coming from the left
          if (i % 3 == 0) {                                                            // every 7 enemies (and 0) --> move faster
            xLeftEnemySpeed[i] = 6;      
          } else {
            xLeftEnemySpeed[i] = 4;
          }
        } else {                                                                       // greater than 15
          if (i < leftEnemyAmount - 1) {                                               // to make sure it does not exceed the amount of left enemies in the array
            leftTimeInterval = 2;                                                      // supposed to allow left enemies to start moving faster
            xLeftEnemySpeed[i] = 8;
            xLeftEnemySpeed[i + 1] = 8;                                                // two of them start moving at the same time
          }
          if (i % 2 == 0) {                                                            // even-numbered left enemies on top
            yLeftEnemy[i] = yGround - (enemyHeight * 2);                               // trying to stack these guys --> intimidating
          }
        }
      }

      xLeftEnemy[i] += xLeftEnemySpeed[i];

      // DAMAGE FROM THE LEFT
      dLeft = dist(xLeftEnemy[i], yLeftEnemy[i], xBody, yBody);
      if (dLeft < bodyWidth) {
        takingDmg = true;
        if (lengthHP >= 0) {
          lengthHP -= 0.33;
        }
      }

      // Top POM POM                                                    // Children in their red winter gear
      fill(249, 192, 200);
      ellipse(xLeftEnemy[i] + enemyWidth/4.55, yLeftEnemy[i] - enemyWidth/2.2, 
              enemyWidth*0.45, enemyWidth*0.4);
      // Right POM POM
      ellipse(xLeftEnemy[i] + enemyWidth, yLeftEnemy[i] + enemyHeight*0.75, 
              enemyWidth*0.3, enemyWidth*0.3);
      // Head
      fill(255, 149, 140);
      rect(xLeftEnemy[i], yLeftEnemy[i], enemyWidth, enemyHeight);
      // Hat
      fill(238, 29, 57);
      ellipse(xLeftEnemy[i] + enemyWidth/2.14, yLeftEnemy[i] + enemyHeight*0.25, 
              enemyWidth*1.2, enemyHeight*1.25);       
      // Stripe on hat
      fill(255, 192, 201);
      ellipse(xLeftEnemy[i] + enemyWidth/2, yLeftEnemy[i] + enemyHeight/2.5, 
              enemyWidth*1.1, enemyHeight*1.15);
      fill(238, 29, 57);
      ellipse(xLeftEnemy[i] + enemyWidth/2, yLeftEnemy[i] + enemyHeight/2.3, 
              enemyWidth*1.05, enemyHeight*1.1);
      // face colour
      fill(255, 149, 140);
      ellipse(xLeftEnemy[i] + enemyWidth/2, yLeftEnemy[i] + enemyHeight/2, 
              enemyWidth, enemyHeight);
      // their left eye (our right)
      fill(0);
      ellipse(xLeftEnemy[i] + enemyWidth - enemyWidth/1.7, yLeftEnemy[i] + enemyHeight*0.4, 
              enemyWidth * 0.1, enemyHeight * 0.2);
      // their right eye (our left)
      ellipse(xLeftEnemy[i] + enemyWidth*0.75, yLeftEnemy[i] + enemyHeight*0.4, 
              enemyWidth*0.1, enemyHeight*0.2);
      // mouth
      strokeWeight(2.5);
      stroke(0);
      line(xLeftEnemy[i] + enemyWidth*0.7, yLeftEnemy[i] + enemyHeight*0.64, 
           xLeftEnemy[i] + enemyWidth*0.6, yLeftEnemy[i] + enemyHeight*0.74);
      line(xLeftEnemy[i] + enemyWidth*0.6, yLeftEnemy[i] + enemyHeight*0.74, 
           xLeftEnemy[i] + enemyWidth*0.48, yLeftEnemy[i] + enemyHeight*0.64);
      noStroke();
      // Scarf
      fill(207, 18, 89);
      rect(xLeftEnemy[i], yLeftEnemy[i] + enemyHeight*0.75, 
           enemyWidth, enemyHeight*0.25);
      fill(238, 224, 203);
      rect(xLeftEnemy[i] + enemyWidth*0.2, yLeftEnemy[i] + enemyHeight*0.75, 
           enemyWidth * 0.8, enemyHeight*0.25);
      fill(207, 18, 89);
      rect(xLeftEnemy[i] + enemyWidth*0.4, yLeftEnemy[i] + enemyHeight*0.75, 
           enemyWidth * 0.6, enemyHeight*0.25);
      fill(238, 224, 203);
      rect(xLeftEnemy[i] + enemyWidth*0.6, yLeftEnemy[i] + enemyHeight*0.75, 
           enemyWidth * 0.4, enemyHeight*0.25);
      fill(207, 18, 89);
      rect(xLeftEnemy[i] + enemyWidth*0.8, yLeftEnemy[i] + enemyHeight*0.75, 
           enemyWidth * 0.2, enemyHeight*0.25);
      // Left POM POM
      fill(249, 192, 200);
      ellipse(xLeftEnemy[i], yLeftEnemy[i] + enemyHeight*0.75, 
              enemyWidth*0.3, enemyWidth*0.3);
    }
  }
}

void sunDamage() {
  if (isDay && inShade == false) {                                   // if snowman in direct sunlight?                          
    lengthHP -= 0.15;                                                // #SUNBURNT
    textSize(25);
    fill(255, 0, 0);
    if (pickedBowtie) {
      text("hot!", xHead - headWidth/2, yHead - headHeight/1.27);    // the text "hot!" has to be slightly higher if the snowman's wearing a bowtie :)
    } else {
      text("hot!", xHead - headWidth/2, yHead - headHeight/1.6);
    }
    text("SURNBURNING", xHP, yHP);
  }
}

void HP() {
  // HP bar top left corner
  fill(226, 255, 179);
  rect(xHP, yHP, 165, heightHP);
  if (lengthHP >= 82) {                             // HP is green if above 1/2
    fill(146, 244, 0);
  } else if (lengthHP >= 30) {
    fill(228, 135, 135);                            // HP turns red when below 1/2
  } else {
    fill(195, 0, 0);                                // but HP turns ReAlLy red at the 30HP mark
  }
  rect(xHP, yHP, lengthHP, heightHP);
  
  if (lengthHP <= 0) {                              // game over if you run  out of HP
    screen = "gameOver";
  }
}

void gameScreen() {

  // keeping snowman's head relative to the body (updating)
  headWidth = bodyHeight * 2/3;
  headHeight = bodyHeight * 2/3;
  xHead = xBody;
  yHead = yBody - bodyHeight/3 - headHeight/2;

  yBody -= jumpSpeed;                          // yBott technically has jumpSpeed always subtracting from it (just that sometimes jumpSpeed = 0)
  jumpSpeed -= gravity;               

  // Boundary check
  if (yBody > yGround - bodyHeight/2) {        // Make sure snowman does not fall through ground
    yBody = yGround - bodyHeight/2;
  }

  // draws sky/background
  sky();
  noStroke();

  snowfall();

  HP();

  sun();
  
  // Houses
  neighbourhood();

  // Sidewalk
  stroke(53, 53, 53);
  strokeWeight(10);
  fill(178, 178, 178);
  rect(xGround - 10, ySidewalk, width + 15, 75);
  fill(0, 0, 0, neighbourhoodAlpha);
  stroke(0, 0, 0, neighbourhoodAlpha);
  rect(xGround - 10, ySidewalk, width + 15, 75);
  noStroke();

  // Ground
  fill(246, 246, 246);
  rect(xGround, yGround, width, height/2);
  fill(255);                                              // white snow on top of ground
  rect(xGround, yGround, width, height/10);

  // draws shadow
  shadow();

  // draws tree
  tree();
  
  // your singular snowball :') b/c it's easier to code just one
  snowball();
  
  // draws snowman player
  player();

  // draws the kids
  enemies();
  
  sunDamage();

  ////println("KeyCde:" + keyCode + " hurt? " + takingDmg + " ySun:" + ySun + 
  // //       " isDay?" + isDay + " inShade?" + inShade + " snowThrown?" + snowThrown + " canClick?" + canClick);
  //println(neighbourhoodAlpha + " isDay?" + isDay + " isAlmostDay?" + isAlmostDay);
}

void gameOver() {
  background(0);
  textSize(125);
  fill(255);
  text("GAME OVER.", 90, height/2);
  textSize(30);
  text("(refresh to try again!)", width/2 - 100, height*0.65);
  textSize(15);
  text("(if you want to)", width/2 - 60, height*0.8);
}

void win() {
  background(142, 167, 242);
  textSize(35);
  fill(0);
  text("CongRATS! You got your hat!", 40, 60); 
  text("Unfortunately, it turns out that as a snowman", 40, 130);
  text("you're just more suseptible to sunburns!", 40, 175);
  text("Even though you have your hat, it's just", 40, 220);
  text("not enough for full coverage.", 40, 260);
  text("But, don't worry!", 40, 320);
  text("That's why we have...", 40, 360);
  fill(255, 221, 241);
  text("Sheer Zinc Suncreen Lotion", 40, 420);
  text("Broad Spectrum SPF 50", 40, 460);
  fill(232, 241, 255);
  text("Stay safe and wear", 40, 540);
  text("sunscreen, kids.", 40, 580);
  
  image(sunscreen, width/2, height/2);
  
  // <3
  fill(255, 89, 188);
  beginShape();
  vertex(958, 121);
  vertex(959, 111);
  vertex(955, 88);
  vertex(943, 68);
  vertex(925, 59);
  vertex(905, 64);
  vertex(890, 65);
  vertex(881, 73);
  vertex(871, 85);
  vertex(869, 91);
  vertex(861, 109);
  vertex(860, 119);
  vertex(864, 135);
  vertex(874, 150);
  vertex(884, 160);
  vertex(893, 169);
  vertex(907, 182);
  vertex(916, 190);
  vertex(931, 199);
  vertex(936, 214);
  vertex(945, 227);
  vertex(950, 236);
  vertex(948, 248);
  vertex(958, 236);
  vertex(971, 228);
  vertex(988, 206);
  vertex(1003, 199);
  vertex(1014, 194);
  vertex(1022, 179);
  vertex(1028, 175);
  vertex(1039, 166);
  vertex(1050, 156);
  vertex(1058, 135);
  vertex(1060, 119);
  vertex(1055, 102);
  vertex(1052, 93);
  vertex(1048, 91);
  vertex(1035, 86);
  vertex(1014, 78);
  vertex(999, 79);
  vertex(985, 90);
  vertex(978, 92);
  vertex(973, 96);
  vertex(969, 101);
  vertex(964, 111);
  vertex(960, 119);
  endShape();
}

void draw() {

  if (screen.equals("menu")) {
    menu();
  } else if(screen.equals("chooseCharacter")) {
    chooseCharacter();
  } else if (screen.equals("gameScreen")) {
    gameScreen();
  } else if (screen.equals("controls")) {
    controls();
  } else if (screen.equals("story")) {
    story();
  } else if (screen.equals("gameOver")) {
    gameOver();
  } else if (screen.equals("win")) {
    win();
  }
}

void keyPressed() {
  if (screen.equals("controls") || 
      screen.equals("story") || 
      screen.equals("chooseCharacter")) {      
    if (keyCode == 8) {                          // [backspace] to esc from control, story, and character selection screens
      screen = "menu";
    }
  }
  
  if (keyCode == 68) {                           // move right [d]
    faceRight = true;
    if (xBody + bodyWidth/2 < width) {           // right edge boundary (can't go off screen)
      if (yBody < yGround - bodyHeight/2) {      // if snowman is in the air...
        xBody += 16;                             // can move right twice as fast
      } else {
        xBody += 8;
      }
    }
  } else if (keyCode == 65) {                    // move left [a]
    faceRight = false;
    if (xBody - bodyWidth/2 > 0) {               // left edge boundary (can't go off screen)
      if (yBody < yGround - bodyHeight/2) {      // if snowman is in the air...
        xBody -= 16;                             // can move left twice as fast
      } else {
        xBody -= 8;
      }
    }
  }

  if (keyCode == 32 || keyCode == 87) {          // jump [w] or [space]
    if (yBody == yGround - bodyHeight/2) {       // can only jump if on ground first
      jumpSpeed = 12.4;
      gravity = 0.5;
    }
  }

  if (keyCode == 83) {                            // gravity increases [s]
    gravity = 1.4;                                // fall down faster
  }
}

void mouseClicked() {
  if (screen.equals("gameScreen")) {
    timesClicked += 1;
    if (timesClicked >= 1) {                             // purpose of "timesClicked" is just to not let the snowball shoot the moment you choose your character and start the game (cuz clicking the button counts as a click). You technically shoot on your second "click"
      if ((faceRight && mouseX > xBody) ||
          (faceRight == false && mouseX < xBody)) {
        snowThrown = true;
      }
      if (canClick) {                                    // purpose of "canClick" is to limit the player to be able to click (assign the snowball a direction) only once until the snowball flies off-screen and resets at Snowman's body
        slope = (mouseY - yBody) / (mouseX - xBody);     // otherwise the slope would change every time if the player were to click so the snowball is able to change direction midflight (depending where they click) and that's gross
        if (faceRight) {
          faceRightWhenClicked = true;                   // the purpose of THIS ONE is to make sure the snowball travels in the same direction it was when shot and doesn't change even if the snowman is facing the opposite direction to what it originallly was when the snowball was shot
        } else {
          faceRightWhenClicked = false;                  // without this, if the player shot the ball when snowman was facing right and then switched to face left even before the snowball was done moving (still on screen) the snowball would move in the opposite direction midflight (due to some code written in the snowball() function)  
        }
      }                                                       
    }
  }
  println("vertex(" + mouseX + ", " + mouseY + ");");
}
